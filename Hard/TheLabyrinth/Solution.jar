import java.util.*;
import java.io.*;
import java.math.*;

/**
 * Auto-generated code below aims at helping you parse the standard input
 * according to the problem statement.
 **/
class Player {
	static int A;

	public static void main(String args[]) {
		Scanner in = new Scanner(System.in);
		int R = in.nextInt(); // number of rows.
		int C = in.nextInt(); // number of columns.
		A = in.nextInt(); // number of rounds between the time the alarm countdown is activated and the
							// time the alarm goes off.
		System.err.println(R + " " + C + " " + A);
		// game loop
		boolean escapeInTime=false;
		char state = 'e';
		while (true) {

			int KR = in.nextInt(); // row where Kirk is located.
			int KC = in.nextInt(); // column where Kirk is located.
			System.err.println(KR + " " + KC);

			Point[][] map = new Point[R][C];

			for (int i = 0; i < R; i++) {

				String s = in.next();
				System.err.println(s);

				char[] ROW = s.toCharArray();
				for (int j = 0; j < ROW.length; j++) {
					Point p = new Point(j, i, ROW[j]);
					map[i][j] = p;
				}
			}

			createConnections(map);

			if (!escapeInTime) {
				escapeInTime=EscapeInTime(map, KR, KC);
				if(escapeInTime) {
					state='c';
				}
			} 

			switch (state) {
			case ('e'): {
				System.err.println("EXPLORE");

				LinkedList<Point> path = Disstar(map[KR][KC], '?');
				Point next = path.remove(1);
				System.out.println(getDirection(next, KR, KC));
				break;
			}
			case ('c'): {
				System.err.println("C State");

				LinkedList<Point> path = Disstar(map[KR][KC], 'C');
				Point next = path.remove(1);
				System.out.println(getDirection(next, KR, KC));

				if (path.size() == 1) {
					state = 't';
				}
				break;
			}
			case ('t'): {
				System.err.println("T State");

				LinkedList<Point> path = Disstar(map[KR][KC], 'T');
				Point next = path.remove(1);
				System.out.println(getDirection(next, KR, KC));

				break;
			}
			}
		}
	}
	

	private static String getDirection(Point next, int kR, int kC) {
	
		if(kR-1	==	next.getY()) {
			return "UP";
		}
		else if(kR+1 == next.getY())
		{
			return "DOWN";
		}
		else if (kC-1	==	next.getX()) {
			return "LEFT";
		}
		else if (kC+1	==	next.getX()) {
			return "RIGHT";
		}
		
		return "ERROR";
	}


	private static boolean EscapeInTime(Point[][] map, int kR, int kC) {
		
		Point CPoint =	findPoint(map,'C');
		Point TPoint =	findPoint(map,'T');
		
		if(CPoint  ==   null ||TPoint  ==  null) {
			return false;
		}
		LinkedList<Point> path	=	Disstar(CPoint, 'T');
		
		if(path  ==  null) {return false;}
		if( path.size()-1  <=  A) {
			return true;
		}
		return false;
	}

	private static Point findPoint(Point [][] map ,char c) {
		for(int i =0; i <map.length ; i++) {	
			for(int j=0 ; j < map[i].length ; j++) {
				
				if(map[i][j].getVal() == c) {
					return map[i][j];
				}
				
				
			}
		}
		return null;
	}


	private static LinkedList<Point> Disstar(Point start, char goalVal) {
		start.setDistance(0);

		Set<Point> settled 			= new HashSet<>();
		ArrayList<Point> unsetteld	= new ArrayList<>();
		unsetteld.add(start);

		while (!unsetteld.isEmpty()) {
			Collections.sort(unsetteld, new PointComperator());
			Point currentPoint = unsetteld.remove(0);

			if (currentPoint.getVal() == goalVal) {
				LinkedList<Point> shortesPath = new LinkedList<>(currentPoint.getShortestPath());
				shortesPath.add(currentPoint);
				
				resetPoints(settled,unsetteld);	
				return shortesPath;
			}

			for (Point p : currentPoint.getNeib()) {

				if (!settled.contains(p) && !unsetteld.contains(p)) {
					unsetteld.add(p);

					if (currentPoint.getDistance() + 1 < p.getDistance()) {
						p.setDistance(currentPoint.getDistance() + 1);

						LinkedList<Point> shortesPath = new LinkedList<>(currentPoint.getShortestPath());
						shortesPath.add(currentPoint);
						p.setShortestPath(shortesPath);
					}
				}

			}
			settled.add(currentPoint);
		}
		
		resetPoints(settled,unsetteld);
		return null;
	}

	private static void resetPoints(Set<Point> settled, ArrayList<Point> unsetteld) {
		
		for(Point p : unsetteld) {
			p.reset();		
		}
		for(Point p : settled) {
			p.reset();
		}
		
	}


	static void createConnections(Point[][] map) {

		for (int i = 0 ; i < map.length ; i++) {
			for (int j = 0 ; j < map[i].length ; j++) {

				if (map[i][j].getVal() == '.' ||   map[i][j].getVal() == 'C'||   map[i][j].getVal() == 'T' ) {
					if (j < map[i].length - 1) {
						if (map[i][j + 1].getVal() != '#' ) {
							map[i][j].accConec(map[i][j + 1]);
							map[i][j + 1].accConec(map[i][j]);
						}
					}
					if (i < map.length - 1) {
						if (map[i + 1][j].getVal() != '#' ) {
							map[i][j].accConec(map[i + 1][j]);
							map[i + 1][j].accConec(map[i][j]);
						}
					}

				} else if (map[i][j].getVal() == '?') {
					if (j < map[i].length - 1) {
						if (map[i][j + 1].getVal() == '.'||map[i][j+1].getVal() == 'C'||map[i][j+1].getVal() == 'T') {
							map[i][j].accConec(map[i][j + 1]);
							map[i][j + 1].accConec(map[i][j]);
						}
					}
					if (i < map.length - 1) {
						if (map[i + 1][j].getVal() == '.'||map[i+1][j].getVal() == 'C'||map[i+1][j].getVal() == 'T' ) {
							map[i][j].accConec(map[i + 1][j]);
							map[i + 1][j].accConec(map[i][j]);
						}
					}

				}

			}
		}

	}
}
class PointComperator implements Comparator<Point> {

	@Override
	public int compare(Point o1, Point o2) {

		if (o1.getDistance() > o2.getDistance())
			return 1;
		else if (o1.getDistance() < o2.getDistance())
			return -1;
		else
			return 0;
	}

}

class Point {
	private int x;
	private int y;
	private int dis;
	private ArrayList<Point> neibours = new ArrayList<>();
	private LinkedList<Point> shortestPath = new LinkedList<>();
	// ? . T C
	private char value;

	Point(int x, int y, char value) {
		this.x 		= x;
		this.y 		= y;
		this.value 	= value;
		this.dis 	=Integer.MAX_VALUE;
	}
	public void reset() {
		dis=Integer.MAX_VALUE;
		shortestPath=new LinkedList<>();
		
	}
	void accConec(Point p) {
		neibours.add(p);
	}
	void setDistance(int dis) {
		this.dis=dis;
	}
	int getDistance() {
		return dis;
	}

	LinkedList<Point> getShortestPath() {
		return shortestPath;
	}

	void setShortestPath(LinkedList<Point> shortestPath) {
		this.shortestPath = shortestPath;
	}

	ArrayList<Point> getNeib() {
		return neibours;
	}

	int getX() {
		return x;
	}

	int getY() {
		return y;
	}

	char getVal() {
		return value;
	}
}